package com.example.snehitsagi.learn_arduino;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

;

public class BlankFragment extends Fragment {

    public BlankFragment() {
        // Required empty public constructor
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        View rootView = inflater.inflate(R.layout.notes_tab, container, false);

        RecyclerView rv = (RecyclerView) rootView.findViewById(R.id.recyclerView);
        rv.setHasFixedSize(true);

        MyAdapter adapter = new MyAdapter(new String[]{"01", "02", "03", "04", "05" , "06" , "07","08","09"},
                new String[]{"Introduction","Arduino Board","Arduino Software","Program Structure","Sketch","Control Statements","Loop Statements","Operators","Data Types"},
                new String[]{
                        "Arduino is an open-source electronics platform based on easy-to-use hardware and software. Arduino boards are able to read inputs - light on a sensor, a finger on a button, or a Twitter message - and turn it into an output - activating a motor, turning on an LED, publishing something online. You can tell your board what to do by sending a set of instructions to the microcontroller on the board. To do so you use the Arduino programming language (based on Wiring), and the Arduino Software (IDE), based on Processing. \n\nArduino was born at the Ivrea Interaction Design Institute as an easy tool for fast prototyping, aimed at students without a background in electronics and programming. As soon as it reached a wider community, the Arduino board started changing to adapt to new needs and challenges, differentiating its offer from simple 8-bit boards to products for IoT applications, wearable, 3D printing, and embedded environments. \n\n\nWhy Arduino ?\n\nThanks to its simple and accessible user experience, Arduino has been used in thousands of different projects and applications. The Arduino software is easy-to-use for beginners, yet flexible enough for advanced users. It runs on Mac, Windows, and Linux. Teachers and students use it to build low cost scientific instruments, to prove chemistry and physics principles, or to get started with programming and robotics. Designers and architects build interactive prototypes, musicians and artists use it for installations and to experiment with new musical instruments.\nAnyone - children, hobbyists, artists, programmers - can start tinkering just following the step by step instructions of a kit, or sharing ideas online with other members of the Arduino community.\n\nThere are many other microcontrollers and microcontroller platforms available for physical computing. Parallax Basic Stamp, Netmedia's BX-24, Phidgets, MIT's Handyboard, and many others offer similar functionality. All of these tools take the messy details of microcontroller programming and wrap it up in an easy-to-use package. Arduino also simplifies the process of working with microcontrollers, but it offers some advantage for teachers, students, and interested amateurs over other systems.\nArduino boards are relatively inexpensive compared to other microcontroller platforms. The least expensive version of the Arduino module can be assembled by hand, and even the pre-assembled Arduino modules cost less than $50.\n\n\nCross Platform:\n\nThe Arduino Software (IDE) runs on Windows, Macintosh OSX, and Linux operating systems. Most microcontroller systems are limited to Windows. Simple, clear programming environment - The Arduino Software (IDE) is easy-to-use for beginners, yet flexible enough for advanced users to take advantage of as well. For teachers, it's conveniently based on the Processing programming environment, so students learning to program in that environment will be familiar with how the Arduino IDE works.\n\nOpen source and extensible software - The Arduino software is published as open source tools, available for extension by experienced programmers. The language can be expanded through C++ libraries, and people wanting to understand the technical details can make the leap from Arduino to the AVR C programming language on which it's based. Similarly, you can add AVR-C code directly into your Arduino programs if you want to.\n\nOpen source and extensible hardware - The plans of the Arduino boards are published under a Creative Commons license, so experienced circuit designers can make their own version of the module, extending it and improving it. Even relatively inexperienced users can build the breadboard version of the module in order to understand how it works and save money.",
                        "In this chapter, we will learn about the different components on the Arduino board. We will study the Arduino UNO board because it is the most popular board in the Arduino board family. In addition, it is the best board to get started with electronics and coding. Some boards look a bit different from the one given below, but most Arduinos have majority of these components in common.\n\n\nBoard Description :\n\n\n1)Power USB\nArduino board can be powered by using the USB cable from your computer. All you need to do is connect the USB cable to the USB connection (1).\n\n\n2)Barrel Jack\nArduino boards can be powered directly from the AC mains power supply by connecting it to the Barrel Jack (2).\n\n\n3)Voltage Regulator\nThe function of the voltage regulator is to control the voltage given to the Arduino board and stabilize the DC voltages used by the processor and other elements.\n\n\n4)Crystal Oscillator\nThe crystal oscillator helps Arduino in dealing with time issues. How does Arduino calculate time? The answer is, by using the crystal oscillator. The number printed on top of the Arduino crystal is 16.000H9H. It tells us that the frequency is 16,000,000 Hertz or 16 MHz.\n\n\n5)Arduino Reset\nYou can reset your Arduino board, i.e., start your program from the beginning. You can reset the UNO board in two ways. First, by using the reset button (17) on the board. Second, you can connect an external reset button to the Arduino pin labelled RESET (5).\n\n\nPins\n3.3V (6) − Supply 3.3 output volt\n5V (7) − Supply 5 output volt\nMost of the components used with Arduino board works fine with 3.3 volt and 5 volt.\n\n\nGND (8)(Ground)\nThere are several GND pins on the Arduino, any of which can be used to ground your circuit.\n\n\nVin (9)\nThis pin also can be used to power the Arduino board from an external power source, like AC mains power supply.\n\n\nAnalog pins\nThe Arduino UNO board has five analog input pins A0 through A5. These pins can read the signal from an analog sensor like the humidity sensor or temperature sensor and convert it into a digital value that can be read by the microprocessor.\n\n\nMain microcontroller\nEach Arduino board has its own microcontroller (11). You can assume it as the brain of your board. The main IC (integrated circuit) on the Arduino is slightly different from board to board. The microcontrollers are usually of the ATMEL Company. You must know what IC your board has before loading up a new program from the Arduino IDE. This information is available on the top of the IC. For more details about the IC construction and functions, you can refer to the data sheet.\n\n\nICSP pin\nMostly, ICSP (12) is an AVR, a tiny programming header for the Arduino consisting of MOSI, MISO, SCK, RESET, VCC, and GND. It is often referred to as an SPI (Serial Peripheral Interface), which could be considered as an \"expansion\" of the output. Actually, you are slaving the output device to the master of the SPI bus.\n\n\nPower LED indicator\nThis LED should light up when you plug your Arduino into a power source to indicate that your board is powered up correctly. If this light does not turn on, then there is something wrong with the connection.\nOn your board, you will find two labels: TX (transmit) and RX (receive). They appear in two places on the Arduino UNO board. First, at the digital pins 0 and 1, to indicate the pins responsible for serial communication. Second, the TX and RX led (13). The TX led flashes with different speed while sending the serial data. The speed of flashing depends on the baud rate used by the board. RX flashes during the receiving process.\n\n\nThe Arduino UNO board has 14 digital I/O pins (15) (of which 6 provide PWM (Pulse Width Modulation) output. These pins can be configured to work as input digital pins to read logic values (0 or 1) or as digital output pins to drive different modules like LEDs, relays, etc. The pins labeled “~” can be used to generate PWM.\nAREF stands for Analog Reference. It is sometimes, used to set an external reference voltage (between 0 and 5 Volts) as the upper limit for the analog input pin",
                        "The Arduino Integrated Development Environment - or Arduino Software (IDE) - contains a text editor for writing code, a message area, a text console, a toolbar with buttons for common functions and a series of menus. It connects to the Arduino and Genuino hardware to upload programs and communicate with them.\n\n\nWriting Sketches\n\nPrograms written using Arduino Software (IDE) are called sketches. These sketches are written in the text editor and are saved with the file extension .ino. The editor has features for cutting/pasting and for searching/replacing text. The message area gives feedback while saving and exporting and also displays errors. The console displays text output by the Arduino Software (IDE), including complete error messages and other information. The bottom righthand corner of the window displays the configured board and serial port. The toolbar buttons allow you to verify and upload programs, create, open, and save sketches, and open the serial monitor.\nNOTE:: Versions of the Arduino Software (IDE) prior to 1.0 saved sketches with the extension .pde. It is possible to open these files with version 1.0, you will be prompted to save the sketch with the .ino extension on saving.\n\n\nVerify\n\nChecks your code for errors compiling it.\n\n\nUpload\n\nCompiles your code and uploads it to the configured board. See uploading below for details.\nNote: If you are using an external programmer with your board, you can hold down the \"shift\" key on your computer when using this icon. The text will change to \"Upload using Programmer\"\n\n\nNew\n\nCreates a new sketch.\n\n\nOpen\n\nPresents a menu of all the sketches in your sketchbook. Clicking one will open it within the current window overwriting its content.\nNote: due to a bug in Java, this menu doesn't scroll; if you need to open a sketch late in the list, use the File | Sketchbook menu instead.\n\n\nSave\n\nSaves your sketch.\n\n\nSerial Monitor \n\nOpens the serial monitor. Additional commands are found within the five menus: File, Edit, Sketch, Tools, Help. The menus are context sensitive, which means only those items relevant to the work currently being carried out are available.\n\n\nExamples\n\nAny example provided by the Arduino Software (IDE) or library shows up in this menu item. All the examples are structured in a tree that allows easy access by topic or library.\n\n\nComment/Uncomment\n\nPuts or removes the // comment marker at the beginning of each selected line.\n\n\nUpload Using Programmer\n\nThis will overwrite the bootloader on the board; you will need to use Tools > Burn\nBootloader to restore it and be able to Upload to USB serial port again. However, it allows you to use the full capacity of the Flash memory for your sketch. Please note that this command will NOT burn the fuses. To do so a Tools -> Burn Bootloader command must be executed.\n\n\nExport Compiled Binary\n\nSaves a .hex file that may be kept as archive or sent to the board using other tools.\n\n\nAuto Format\n\nThis formats your code nicely: i.e. indents it so that opening and closing curly braces line up, and that the statements inside curly braces are indented more.\n\n\nArchive Sketch\n\nArchives a copy of the current sketch in .zip format. The archive is placed in the same directory as the sketch.\n\n\nBoard\n\nSelect the board that you're using. See below for descriptions of the various boards.\n\n\nPort\n\nThis menu contains all the serial devices (real or virtual) on your machine. It should automatically refresh every time you open the top-level tools menu.\n\n\nProgrammer\n\nFor selecting a harware programmer when programming a board or chip and not using the onboard USB-serial connection. Normally you won't need this, but if you're burning a bootloader to a new microcontroller, you will use this\n\n\nBurn Bootloader\n\nThe items in this menu allow you to burn a bootloader onto the microcontroller on an Arduino board. This is not required for normal use of an Arduino or Genuino board but is useful if you purchase a new ATmega microcontroller (which normally come without a bootloader). Ensure that you've selected the correct board from the Boards menu before burning the bootloader on the target board. This command also set the right fuses.\n\n\n",
                        "In this chapter, we will study in depth, the Arduino program structure and we will learn more new terminologies used in the Arduino world. The Arduino software is open-source. The source code for the Java environment is released under the GPL and the C/C++ microcontroller libraries are under the LGPL\n\nSketch − The first new terminology is the Arduino program called “sketch”.\n\n\nArduino programs can be divided in three main parts: Structure, Values (variables and constants), and Functions. In this tutorial, we will learn about the Arduino software program, step by step, and how we can write the program without any syntax or compilation error.\n\nSoftware structure consist of two main functions −\n\n1)Setup( ) function\n2)Loop( ) function\n\n\n\nVoid setup ( ) {\n}\nPURPOSE − The setup() function is called when a sketch starts. Use it to initialize the variables, pin modes, start using libraries, etc. The setup function will only run once, after each power up or reset of the Arduino board.\n\n\n\nVoid Loop ( ) {\n}\nPURPOSE − After creating a setup() function, which initializes and sets the initial values, the loop() function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond. Use it to actively control the Arduino board.",
                        "A sketch is the name that Arduino uses for a program. It's the unit of code that is uploaded to and run on an Arduino board\n\n\n\nBlink\n* The basic Arduino example.\n* Turns on an LED on for one second, then off for one second, and so on.\n* We use pin 13 because, depending on your Arduino board, it has either a built-in LED or a built-in resistor so that you need only an LED.\n\n\nEXAMPLE :\n\n/* Blink code */\nint ledPin = 13;   // LED connected to pin 13\n\n\nEverything between the /* and */ is ignored by the Arduino when it runs the sketch.  It's there for people reading the code: to explain what the program does, how it works, or why it's written the way it is. It's a good practice to comment your sketches, and to keep the comments up-to-date when you modify the code. This helps other people to learn from or modify your code\n\nThere's another style for short, single-line comments. These start with // and continue to the end of the line.\n\n\n\nVARIABLES\n\nA variable is a place for storing a piece of data. It has a name, a type, and a value. For example, the line from the Blink sketch above declares a variable with the name ledPin, the type int, and an initial value of 13. It's being used to indicate which Arduino pin the LED is connected to. Every time the name ledPin appears in the code, its value will be retrieved. In this case, the person writing the program could have chosen not to bother creating the ledPin variable and instead have simply written 13 everywhere they needed to specify a pin number. The advantage of using a variable is that it's easier to move the LED to a different pin: you only need to edit the one line that assigns the initial value to the variable.\nOften, however, the value of a variable will change while the sketch runs. For example, you could store the value read from an input into a variable.\n\n\n\n\nFUNCTIONS\n\nA function (otherwise known as a procedure or sub-routine) is a named piece of code that can be used from elsewhere in a sketch. For example, here's the definition of the setup() function from the Blink example:\n\nvoid setup()\n{\ninMode(ledPin, OUTPUT);   // the digital pin as output\n}\n\n\nThe first line provides information about the function, like its name, \"setup\". The text before and after the name specify its return type and parameters: these will be explained later. The code between the { and } is called the body of the function: what the function does.\n\nYou can call a function that's already been defined (either in your sketch or as part of the Arduino language). For example, the line pinMode(ledPin, OUTPUT); calls the pinMode() function, passing it two parameters: ledPin and OUTPUT. These parameters are used by the pinMode() function to decide which pin and mode to set.\n\n\n\npinMode(), digitalWrite(), and delay()\n\nThe pinMode() function configures a pin as either an input or an output. To use it, you pass it the number of the pin to configure and the constant INPUT or OUTPUT. When configured as an input, a pin can detect the state of a sensor like a pushbutton; this is discussed in a later tutorial. As an output, it can drive an actuator like an LED.\n\nThe digitalWrite() functions outputs a value on a pin. For example, the line:\n\ndigitalWrite(ledPin, HIGH);\n\nset the ledPin (pin 13) to HIGH, or 5 volts. Writing a LOW to pin connects it to ground, or 0 volts.\n\n\nThe delay() causes the Arduino to wait for the specified number of milliseconds before continuing on to the next line. There are 1000 milliseconds in a second, so the line:\ndelay(1000);   \n//creates a delay of one second\n\n\nsetup() and loop()\n\nThere are two special functions that are a part of every Arduino sketch: setup() and loop(). The setup() is called once, when the sketch starts. It's a good place to do setup tasks like setting pin modes or initializing libraries. The loop() function is called over and over and is heart of most sketches. You need to include both functions in your sketch, even if you don't need them for anything.",
                        "Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false\n\n\nFollowing is the general form of a typical decision making structure found in most of the programming languages −\n\n1. If statement\nIt takes an expression in parenthesis and a statement or block of statements. If the expression is true then the statement or block of statements gets executed otherwise these statements are skipped.\n\n2. If…else statement\nAn if statement can be followed by an optional else statement, which executes when the expression is false.\n\n3. If…else if …else statement\nThe if statement can be followed by an optional else if...else statement, which is very useful to test various conditions using single if...else if statement.\n\n4. switch case statement\nSimilar to the if statements, switch...case controls the flow of programs by allowing the programmers to specify different codes that should be executed in various conditions.\n\n5. Conditional Operator ? :\nThe conditional operator ? : is the only ternary operator in C.",
                        "Programming languages provide various control structures that allow for more complicated execution paths.\nA loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −\n\n\n1. while loop\nwhile loops will loop continuously, and infinitely, until the expression inside the parenthesis, () becomes false. Something must change the tested variable, or the while loop will never exit.\n\n2. do…while loop\nThe do…while loop is similar to the while loop. In the while loop, the loop-continuation condition is tested at the beginning of the loop before performed the body of the loop.\n\n3. for loop\nA for loop executes statements a predetermined number of times. The control expression for the loop is initialized, tested and manipulated entirely within the for loop parentheses.\n\n4. Nested Loop\nC language allows you to use one loop inside another loop. The following example illustrates the concept.\n\n5. Infinite loop\nIt is the loop having no terminating condition, so the loop becomes infinite.",
                        "An operator is a symbol that tells the compiler to perform specific mathematical or logical functions. C language is rich in built-in operators and provides the following types of operators −\n\n1. 1)Arithmetic Operators\n2. 2)Comparison Operators\n3. 3)Boolean Operators\n4. 4)Bitwise Operators\n5. 5)Compound Operators\n\n\nAssume variable A holds 10 and variable B holds 20 then −\n\n\nARITHMETIC OPERATORS\n\n'=' Stores the value to the right of the equal sign in the variable to the left of the equal sign.A = B\n '+'  Adds two operands\tA + B will give 30\n '-' Subtracts second operand from the first. A - B will give -10\n '*' Multiply both operands. A * B will give 200\n '/'    Divide numerator by denominator. B / A will give 2\n '%'    Modulus Operator and remainder of after an integer division. B % A will give 0\n\n\nCOMPARISION OPERATORS\n\n '==' Checks if the value of two operands is equal or not, if yes then condition becomes true. (A == B) is not true\n '!='    Checks if the value of two operands is equal or not, if values are not equal then condition becomes true. (A != B) is true\n '<'    Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true. (A < B) is true\n '>'  Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true. (A > B) is not true\n '<='  Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.(A <= B) is true\n '>='    Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true. (A >= B) is not true\n\n\nBOOLEAN OPERATORS\n\n '&&' Called Logical AND operator. If both the operands are non-zero then then condition becomes true. (A && B) is true\n '||'    Called Logical OR Operator. If any of the two operands is non-zero then then condition becomes true. (A || B) is true\n '!' Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false. !(A && B) is false\n\n\nBITWISE OPERATORS\n\n '&'  Binary AND Operator copies a bit to the result if it exists in both operands. (A & B) will give 12 which is 0000 1100\n '|'    Binary OR Operator copies a bit if it exists in either operand. (A | B) will give 61 which is 0011 1101\n '^'    Binary XOR Operator copies the bit if it is set in one operand but not both. (A ^ B) will give 49 which is 0011 0001\n '~'  Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. (~A ) will give -60 which is 1100 0011\n '<<'   Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand. A << 2 will give 240 which is 1111 0000\n '>>'  Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand. A >> 2 will give 15 which is 0000 1111\n\n\nCOMPOUND OPERATORS\n\n '++'   Increment operator, increases integer value by one. A++ will give 11\n '--' Decrement operator, decreases integer value by one. A-- will give 9\n'+='   Add AND assignment operator. It adds right operand to the left operand and assign the result to left operand. B += A is equivalent to B = B+ A\n '-='   Subtract AND assignment operator. It subtracts right operand from the left operand and assign the result to left operand. B -= A is equivalent to B = B - A",
                        "Data types in C refers to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in the storage and how the bit pattern stored is interpreted\n\nThe following  provides all the data types that you will use during Arduino programming\n\n\n1. void\nThe void keyword is used only in function declarations. It indicates that the function is expected to return no information to the function from which it was called.\nExample:\nVoid Loop(){\n// rest code\n}\n\n2. Boolean\nA Boolean holds one of two values, true or false. Each Boolean variable occupies one byte of memory.\nExample:\nboolean val = false ;\nboolean state = true ;\n\n3. Char\nA data type that takes up one byte of memory that stores a character value. Character literals are written in single quotes like this: 'A' and for multiple characters, strings use double quotes: \"ABC\".\nHowever, characters are stored as numbers. You can see the specific encoding in the ASCII chart. This means that it is possible to do arithmetic operations on characters, in which the ASCII value of the character is used. For example, 'A' + 1 has the value 66, since the ASCII value of the capital letter A is 65.\nExample:\nChar chr_a = ‘a’;\nChar chr_c = 97;\n;//declaration of variable with type char and initialize it with character 97 in ASCII Char Table\n\n4. Unsigned char\nUnsigned char is an unsigned data type that occupies one byte of memory. The unsigned char data type encodes numbers from 0 to 255.\nExample:\nUnsigned Char chr_y = 121 ;\n\n5. Byte\nA byte stores an 8-bit unsigned number, from 0 to 255.\nExample:\nbyte m = 25;\n\n6. Int\nIntegers are the primary data-type for number storage. int stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2^15 and a maximum value of (2^15) - 1).\nThe int size varies from board to board. On the Arduino Due, for example, an int stores a 32-bit (4-byte) value. This yields a range of -2,147,483,648 to 2,147,483,647 (minimum value of -2^31 and a maximum value of (2^31) - 1).\nExample:\nint counter = 32 ;\n\n7. Unsigned int\nUnsigned ints (unsigned integers) are the same as int in the way that they store a 2 byte value. Instead of storing negative numbers, however, they only store positive values, yielding a useful range of 0 to 65,535 (2^16) - 1). The Due stores a 4 byte (32-bit) value, ranging from 0 to 4,294,967,295 (2^32 - 1).\nExample:\nUnsigned int counter = 60 ; \n\n8. Word\nOn the Uno and other ATMEGA based boards, a word stores a 16-bit unsigned number. On the Due and Zero, it stores a 32-bit unsigned number.\nExample:\nword w = 1000 ;\n\n9. Long\nLong variables are extended size variables for number storage, and store 32 bits (4 bytes), from 2,147,483,648 to 2,147,483,647.\nExample:\nLong velocity = 102346 ;\n\n10. Short\nA short is a 16-bit data-type. On all Arduinos (ATMega and ARM based), a short stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2^15 and a maximum value of (2^15) - 1).\nExample:\nshort val = 13 ;\n\n11.Float\nData type for floating-point number is a number that has a decimal point. Floating-point numbers are often used to approximate the analog and continuous values because they have greater resolution than integers.\nFloating-point numbers can be as large as 3.4028235E+38 and as low as 3.4028235E+38. They are stored as 32 bits (4 bytes) of information.\nExample:\nfloat num = 1.352;\n\n12. Double\nOn the Uno and other ATMEGA based boards, Double precision floating-point number occupies four bytes. That is, the double implementation is exactly the same as the float, with no gain in precision. On the Arduino Due, doubles have 8-byte (64 bit) precision.\nExample:\ndouble num = 45.352 ;"
                },
                rootView.getContext());
        rv.setAdapter(adapter);

        LinearLayoutManager llm = new LinearLayoutManager(getActivity());
        rv.setLayoutManager(llm);

        return rootView;
    }

}